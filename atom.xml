<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sunnyxd&#39;s blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sunnyxd.com/"/>
  <updated>2016-06-28T06:20:52.145Z</updated>
  <id>http://www.sunnyxd.com/</id>
  
  <author>
    <name>xiaodong.fan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java NIO浅析</title>
    <link href="http://www.sunnyxd.com/2016/06/28/Java%20NIO%E6%B5%85%E6%9E%90/"/>
    <id>http://www.sunnyxd.com/2016/06/28/Java NIO浅析/</id>
    <published>2016-06-28T06:00:55.000Z</published>
    <updated>2016-06-28T06:20:52.145Z</updated>
    
    <content type="html">&lt;h2 id=&quot;准备知识&quot;&gt;&lt;a href=&quot;#准备知识&quot; class=&quot;headerlink&quot; title=&quot;准备知识&quot;&gt;&lt;/a&gt;准备知识&lt;/h2&gt;&lt;h3 id=&quot;同步、异步、阻塞、非阻塞&quot;&gt;&lt;a href=&quot;#同步、异步、阻塞、非阻塞&quot; class=&quot;headerlink&quot; title=&quot;同步、异步、阻塞、非阻塞&quot;&gt;&lt;/a&gt;同步、异步、阻塞、非阻塞&lt;/h3&gt;&lt;p&gt;同步和异步说的是服务端消息的通知机制，阻塞和非阻塞说的是客户端线程的状态。&lt;br&gt;已客户端一次网络请求为例做简单说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步&lt;br&gt;同步是指一次请求没有得到结果之前就不返回。&lt;/li&gt;
&lt;li&gt;异步&lt;br&gt;请求不会立刻得到最终结果，服务器处理完成再异步通知客户端。&lt;/li&gt;
&lt;li&gt;阻塞&lt;br&gt;请求结果返回之前，当前线程被挂起。在此期间不能做任何其他的事情。&lt;/li&gt;
&lt;li&gt;非阻塞&lt;br&gt;请求立即返回，后续由客户端时不时的询问服务器结果或者服务器异步回调。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;同步IO、异步IO、阻塞IO、非阻塞IO&quot;&gt;&lt;a href=&quot;#同步IO、异步IO、阻塞IO、非阻塞IO&quot; class=&quot;headerlink&quot; title=&quot;同步IO、异步IO、阻塞IO、非阻塞IO&quot;&gt;&lt;/a&gt;同步IO、异步IO、阻塞IO、非阻塞IO&lt;/h3&gt;&lt;p&gt;通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。&lt;br&gt;已一个&lt;code&gt;IO读取&lt;/code&gt;过程为例做简要说明（如图）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DMA把数据读取到内核空间的缓冲区(读就绪)&lt;/li&gt;
&lt;li&gt;内核将数据拷贝到用户空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7xnxzw.com1.z0.glb.clouddn.com/io%E5%8E%9F%E7%90%86.png&quot; alt=&quot;io%E5%8E%9F%E7%90%86.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;内核空间是用户代码无法控制的，所以用户空间在读取之前，首先会判断是否已经读就绪。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步IO&lt;br&gt;当用户发出IO请求操作之后，内核会去查看要读取的数据是否就绪，如果数据没有就绪，就一直等待。需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户空间。&lt;/li&gt;
&lt;li&gt;异步IO&lt;br&gt;只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。&lt;/li&gt;
&lt;li&gt;阻塞IO&lt;br&gt;当用户线程发起一个IO请求操作（以读请求操作为例），内核查看要读取的数据还没就绪，当前线程被挂起，阻塞等待结果返回。&lt;/li&gt;
&lt;li&gt;非阻塞IO&lt;br&gt;如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当前线程在拿到此次请求结果的过程中，可以做其它事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;JAVA中的BIO、NIO、AIO&quot;&gt;&lt;a href=&quot;#JAVA中的BIO、NIO、AIO&quot; class=&quot;headerlink&quot; title=&quot;JAVA中的BIO、NIO、AIO&quot;&gt;&lt;/a&gt;JAVA中的BIO、NIO、AIO&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;BIO&lt;br&gt;同步阻塞，传统io方式。&lt;br&gt;适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中。&lt;/li&gt;
&lt;li&gt;NIO&lt;br&gt;同步非阻塞，jdk4开始支持。&lt;br&gt;适用于连接数目多且连接比较短（&lt;code&gt;轻操作&lt;/code&gt;）的架构，比如聊天服务器。&lt;/li&gt;
&lt;li&gt;AIO&lt;br&gt;异步非阻塞，jdk7开始支持。&lt;br&gt;适用于连接数目多且连接比较长（&lt;code&gt;重操作&lt;/code&gt;）的架构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;形象的理解NIO和AIO：&lt;br&gt;如果把内核比作快递，NIO就是你要自己时不时到官网查下快递是否已经到了你所在城市，然后自己去取快递；AIO就是快递员送货上门了。&lt;/p&gt;
&lt;h3 id=&quot;Linux下五种IO模型&quot;&gt;&lt;a href=&quot;#Linux下五种IO模型&quot; class=&quot;headerlink&quot; title=&quot;Linux下五种IO模型&quot;&gt;&lt;/a&gt;Linux下五种IO模型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;阻塞I/O（blocking I/O）&lt;/li&gt;
&lt;li&gt;非阻塞I/O （nonblocking I/O）&lt;/li&gt;
&lt;li&gt;I/O复用(select 和poll) （I/O multiplexing）&lt;/li&gt;
&lt;li&gt;信号驱动I/O （signal driven I/O (SIGIO)）&lt;/li&gt;
&lt;li&gt;异步I/O （asynchronous I/O (the POSIX aio_functions)）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;IO复用模型-IO多路复用&quot;&gt;&lt;a href=&quot;#IO复用模型-IO多路复用&quot; class=&quot;headerlink&quot; title=&quot;IO复用模型(IO多路复用)&quot;&gt;&lt;/a&gt;IO复用模型(IO多路复用)&lt;/h4&gt;&lt;p&gt;简言之，就是通过单个线程(进程)来管理多IO流。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xnxzw.com1.z0.glb.clouddn.com/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png&quot; alt=&quot;io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;IO多路复用避免阻塞在IO上，原本为多进程或多线程来接收多个连接的消息变为单进程或单线程保存多个socket的状态后轮询处理。只有当某个socket读写就绪后，才真正调用实际的IO读写操作。这样可以避免线程切换带来的开销。&lt;/p&gt;
&lt;p&gt;实现IO多路复用需要函数来支持，就是你说的linux下的select、poll、epoll以及win下 iocp和BSD的kqueue。这几个函数也会使进程阻塞，但是和阻塞I/O所不同的是，它可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O准备状态进行检测。&lt;/p&gt;
&lt;p&gt;IO多路复用为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在IO多路复用中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xnxzw.com1.z0.glb.clouddn.com/io%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png&quot; alt=&quot;io%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五种IO模型以及select、poll、epoll的详细介绍推荐大家看这篇文章&lt;/strong&gt; &amp;rarr;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/hguisu/article/details/7453390&quot; title=&quot;socket阻塞与非阻塞，同步与异步、I/O模型&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;socket阻塞与非阻塞，同步与异步、I/O模型&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;理解Reactor和Proactor模式&quot;&gt;&lt;a href=&quot;#理解Reactor和Proactor模式&quot; class=&quot;headerlink&quot; title=&quot;理解Reactor和Proactor模式&quot;&gt;&lt;/a&gt;理解Reactor和Proactor模式&lt;/h4&gt;&lt;p&gt;在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时(读写就绪)，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询,如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xnxzw.com1.z0.glb.clouddn.com/reactor%E6%A8%A1%E5%BC%8F.png&quot; alt=&quot;reactor%E6%A8%A1%E5%BC%8F.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;从这里可以看出，多路复用IO就是采用Reactor模式。注意，上面的图中展示的是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。&lt;br&gt;在Proactor模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式。&lt;/p&gt;
&lt;p&gt;这部分摘选自：&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3916526.html&quot; title=&quot;Java NIO：浅析I/O模型&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java NIO：浅析I/O模型&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Java-NIO介绍&quot;&gt;&lt;a href=&quot;#Java-NIO介绍&quot; class=&quot;headerlink&quot; title=&quot;Java NIO介绍&quot;&gt;&lt;/a&gt;Java NIO介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Channels and Buffers（通道和缓冲区）&lt;/strong&gt;&lt;br&gt;标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Non-blocking IO（非阻塞IO）&lt;/strong&gt;&lt;br&gt;Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Selectors（选择器）&lt;/strong&gt;&lt;br&gt;选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。&lt;/p&gt;
&lt;h3 id=&quot;NIO与IO区别&quot;&gt;&lt;a href=&quot;#NIO与IO区别&quot; class=&quot;headerlink&quot; title=&quot;NIO与IO区别&quot;&gt;&lt;/a&gt;NIO与IO区别&lt;/h3&gt;&lt;p&gt;&amp;nbsp;  IO &amp;nbsp;  &amp;nbsp;  &amp;nbsp;  &amp;nbsp;  &amp;nbsp;  &amp;nbsp;  &amp;nbsp;  &amp;nbsp;  NIO&lt;br&gt;面向流&amp;nbsp;  &amp;nbsp;  &amp;nbsp;&amp;nbsp;  &amp;nbsp;               面向缓冲&lt;br&gt;阻塞IO  &amp;nbsp;  &amp;nbsp;  &amp;nbsp;&amp;nbsp;  &amp;nbsp;              非阻塞IO&lt;br&gt;&amp;nbsp;  无&amp;nbsp;  &amp;nbsp;  &amp;nbsp;  &amp;nbsp;  &amp;nbsp;  &amp;nbsp;  &amp;nbsp; &amp;nbsp;                   选择器&lt;/p&gt;
&lt;h3 id=&quot;Channel&quot;&gt;&lt;a href=&quot;#Channel&quot; class=&quot;headerlink&quot; title=&quot;Channel&quot;&gt;&lt;/a&gt;Channel&lt;/h3&gt;&lt;p&gt;Java NIO的通道类似流，但又有些不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。&lt;/li&gt;
&lt;li&gt;通道可以异步地读写。&lt;/li&gt;
&lt;li&gt;通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;Channel的实现&quot;&gt;&lt;a href=&quot;#Channel的实现&quot; class=&quot;headerlink&quot; title=&quot;Channel的实现&quot;&gt;&lt;/a&gt;Channel的实现&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;FileChannel (从文件中读写数据)&lt;/li&gt;
&lt;li&gt;DatagramChannel (通过UDP读写网络中的数据)&lt;/li&gt;
&lt;li&gt;SocketChannel (通过TCP读写网络中的数据)&lt;/li&gt;
&lt;li&gt;ServerSocketChannel (可以监听新进来的TCP连接，像Web服务器那样)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Buffer&quot;&gt;&lt;a href=&quot;#Buffer&quot; class=&quot;headerlink&quot; title=&quot;Buffer&quot;&gt;&lt;/a&gt;Buffer&lt;/h3&gt;&lt;p&gt;Java NIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。&lt;/p&gt;
&lt;h4 id=&quot;Buffer的基本用法&quot;&gt;&lt;a href=&quot;#Buffer的基本用法&quot; class=&quot;headerlink&quot; title=&quot;Buffer的基本用法&quot;&gt;&lt;/a&gt;Buffer的基本用法&lt;/h4&gt;&lt;p&gt;使用Buffer读写数据一般遵循以下四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分配指定大小的buffer空间&lt;/li&gt;
&lt;li&gt;写入数据到Buffer&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;flip()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;从Buffer中读取数据&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;clear()&lt;/code&gt;方法或者&lt;code&gt;compact()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。&lt;/p&gt;
&lt;p&gt;一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。&lt;br&gt;注：Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。&lt;/p&gt;
&lt;h4 id=&quot;Buffer的类型&quot;&gt;&lt;a href=&quot;#Buffer的类型&quot; class=&quot;headerlink&quot; title=&quot;Buffer的类型&quot;&gt;&lt;/a&gt;Buffer的类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ByteBuffer&lt;/li&gt;
&lt;li&gt;MappedByteBuffer&lt;/li&gt;
&lt;li&gt;CharBuffer&lt;/li&gt;
&lt;li&gt;DoubleBuffer&lt;/li&gt;
&lt;li&gt;FloatBuffer&lt;/li&gt;
&lt;li&gt;IntBuffer&lt;/li&gt;
&lt;li&gt;LongBuffer&lt;/li&gt;
&lt;li&gt;ShortBuffer&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Selector&quot;&gt;&lt;a href=&quot;#Selector&quot; class=&quot;headerlink&quot; title=&quot;Selector&quot;&gt;&lt;/a&gt;Selector&lt;/h3&gt;&lt;p&gt;Selector（选择器）是Java NIO中能够检测一到多个通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xnxzw.com1.z0.glb.clouddn.com/nio.png&quot; alt=&quot;nio.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;为什么使用Selector&quot;&gt;&lt;a href=&quot;#为什么使用Selector&quot; class=&quot;headerlink&quot; title=&quot;为什么使用Selector?&quot;&gt;&lt;/a&gt;为什么使用Selector?&lt;/h4&gt;&lt;p&gt;仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。&lt;/p&gt;
&lt;p&gt;但是，需要记住，现代的操作系统和CPU在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。实际上，如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用Selector能够处理多个通道就足够了。&lt;/p&gt;
&lt;h4 id=&quot;NIO如何实现非阻塞？&quot;&gt;&lt;a href=&quot;#NIO如何实现非阻塞？&quot; class=&quot;headerlink&quot; title=&quot;NIO如何实现非阻塞？&quot;&gt;&lt;/a&gt;NIO如何实现非阻塞？&lt;/h4&gt;&lt;p&gt;服务器上所有Channel需要向Selector注册，而Selector则负责监视这些Socket的IO状态(观察者)，当其中任意一个或者多个Channel具有可用的IO操作时，该Selector的select()方法将会返回大于0的整数，该整数值就表示该Selector上有多少个Channel具有可用的IO操作，并提供了selectedKeys（）方法来返回这些Channel对应的SelectionKey集合(一个SelectionKey对应一个就绪的通道)。正是通过Selector，使得服务器端只需要不断地调用Selector实例的select()方法即可知道当前所有Channel是否有需要处理的IO操作。&lt;br&gt;注：java NIO就是多路复用IO，jdk7之后底层是epoll模型。&lt;/p&gt;
&lt;h3 id=&quot;一个简单的demo&quot;&gt;&lt;a href=&quot;#一个简单的demo&quot; class=&quot;headerlink&quot; title=&quot;一个简单的demo&quot;&gt;&lt;/a&gt;一个简单的demo&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * NioServer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Date: 6/27/2016&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Time: 8:06 PM&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @author xiaodong.fan&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class NioServer &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  public static void main(String[] args) throws Exception &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 1、初始化一个ServerSocketChannel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    InetSocketAddress inetSocketAddress = new InetSocketAddress(&amp;quot;127.0.0.1&amp;quot;, 9999);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    serverSocketChannel.configureBlocking(false);// 设置为非阻塞模式，后续的accept()方法会立刻返回&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    serverSocketChannel.socket().bind(inetSocketAddress, 1024);// 监听本地9999端口的请求，第二个参数限制可以建立的最大连接数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Selector selector = Selector.open();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 将通道注册到一个选择器上(非阻塞模式与选择器搭配会工作的更好)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 可以监听四种不同类型的事件：OP_CONNECT，OP_ACCEPT，OP_READ，OP_WRITE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来：SelectionKey.OP_READ | SelectionKey.OP_WRITE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 2、监听连接请求并处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while (true) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      int connects = selector.select(2000);// 每次最多阻塞2秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      if (connects == 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;没有请求...&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        continue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;请求来了...&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      // 获取监听到有连接请求的channel对应的selectionKey&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      // 遍历selectionKey来访问就绪的通道&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Iterator&amp;lt;SelectionKey&amp;gt; selectedKeyIterator = selectedKeys.iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      while (selectedKeyIterator.hasNext()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SelectionKey selectionKey = selectedKeyIterator.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (selectionKey.isValid()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          if (selectionKey.isAcceptable()) &amp;#123;// 接收就绪&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ServerSocketChannel channel = (ServerSocketChannel) selectionKey.channel();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 返回一个包含新进来的连接SocketChannel，因为前面设置的非阻塞模式，这里会立即返回。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            SocketChannel socketChannel = channel.accept();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (socketChannel == null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            socketChannel.configureBlocking(false);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            socketChannel.register(selector, SelectionKey.OP_READ);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;连接建立完成&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            doWrite(socketChannel, &amp;quot;connection is established&amp;quot;);// 连接建立完成，给客户端发消息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125; else if (selectionKey.isReadable()) &amp;#123;// 读就绪&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ByteBuffer readBuffer = ByteBuffer.allocate(10);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while ((socketChannel.read(readBuffer)) &amp;gt; 0) &amp;#123;// // 读取客户端发送来的消息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              readBuffer.flip();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              byte[] bytes = new byte[readBuffer.remaining()];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              readBuffer.get(bytes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              String body = new String(bytes, &amp;quot;utf-8&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              doWrite(socketChannel, body);// 将客户端发送的内容原封不动的发回去&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              readBuffer.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            socketChannel.close();//读取数据完毕后关闭连接，如果不关闭一直处于连接状态。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        selectedKeyIterator.remove(); // 注意每次必须手动remove()，下次该通道变成就绪时，Selector会再次将其放入已选择键集中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  private static void doWrite(SocketChannel socketChannel, String response) throws IOException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (StringUtils.isNotBlank(response)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      byte[] bytes = response.getBytes();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ByteBuffer writeBuffer = ByteBuffer.allocate(1024);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      writeBuffer.put(bytes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      writeBuffer.flip();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      // 发送消息到客户端&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      socketChannel.write(writeBuffer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      writeBuffer.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3916526.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java NIO：浅析I/O模型&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/hguisu/article/details/7453390&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;socket阻塞与非阻塞，同步与异步、I/O模型&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://stevex.blog.51cto.com/4300375/1284437&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java BIO、NIO、AIO 学习&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.cnblogs.com/dolphin0520/p/3919162.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java NIO：NIO概述&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ifeve.com/java-nio-all/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java NIO 系列教程&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/yanmei_yao/article/details/8586199&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java网络编程——使用NIO实现非阻塞Socket通信&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备知识&quot;&gt;&lt;a href=&quot;#准备知识&quot; class=&quot;headerlink&quot; title=&quot;准备知识&quot;&gt;&lt;/a&gt;准备知识&lt;/h2&gt;&lt;h3 id=&quot;同步、异步、阻塞、非阻塞&quot;&gt;&lt;a href=&quot;#同步、异步、阻塞、非阻塞&quot; class=&quot;headerlink&quot; title=&quot;同步、异步、阻塞、非阻塞&quot;&gt;&lt;/a&gt;同步、异步、阻塞、非阻塞&lt;/h3&gt;&lt;p&gt;同步和异步说的是服务端消息的通知机制，阻塞和非阻塞说的是客户端线程的状态。&lt;br&gt;已客户端一次网络请求为例做简单说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步&lt;br&gt;同步是指一次请求没有得到结果之前就不返回。&lt;/li&gt;
&lt;li&gt;异步&lt;br&gt;请求不会立刻得到最终结果，服务器处理完成再异步通知客户端。&lt;/li&gt;
&lt;li&gt;阻塞&lt;br&gt;请求结果返回之前，当前线程被挂起。在此期间不能做任何其他的事情。&lt;/li&gt;
&lt;li&gt;非阻塞&lt;br&gt;请求立即返回，后续由客户端时不时的询问服务器结果或者服务器异步回调。
    
    </summary>
    
      <category term="Java" scheme="http://www.sunnyxd.com/categories/Java/"/>
    
    
      <category term="NIO" scheme="http://www.sunnyxd.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>curl命令常用操作</title>
    <link href="http://www.sunnyxd.com/2016/05/23/curl%E5%91%BD%E4%BB%A4%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://www.sunnyxd.com/2016/05/23/curl命令常用操作/</id>
    <published>2016-05-23T06:55:10.000Z</published>
    <updated>2016-05-23T07:00:19.740Z</updated>
    
    <content type="html">&lt;h2 id=&quot;curl是做什么的&quot;&gt;&lt;a href=&quot;#curl是做什么的&quot; class=&quot;headerlink&quot; title=&quot;curl是做什么的&quot;&gt;&lt;/a&gt;curl是做什么的&lt;/h2&gt;&lt;p&gt;curl是利用URL语法在命令行方式下工作的开源文件传输工具，它支持http,https,ftp,ftps,telnet等多种协议。&lt;br&gt;常用于模拟提交web数据，与网站API交互(POST/GET请求，可以自定义发送header)，也可以用于下载(PS:专职下载还是用wget，支持recursive)。&lt;/p&gt;
&lt;h2 id=&quot;常用操作&quot;&gt;&lt;a href=&quot;#常用操作&quot; class=&quot;headerlink&quot; title=&quot;常用操作&quot;&gt;&lt;/a&gt;常用操作&lt;/h2&gt;&lt;h3 id=&quot;GET请求-G-–get-省略&quot;&gt;&lt;a href=&quot;#GET请求-G-–get-省略&quot; class=&quot;headerlink&quot; title=&quot;GET请求(-G/–get/省略)&quot;&gt;&lt;/a&gt;GET请求(-G/–get/省略)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;curl http://www.xxxx.com/show?userId=111
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;POST请求&quot;&gt;&lt;a href=&quot;#POST请求&quot; class=&quot;headerlink&quot; title=&quot;POST请求&quot;&gt;&lt;/a&gt;POST请求&lt;/h3&gt;&lt;h4 id=&quot;以application-x-www-url-encoded-方式发送数据-d-–data-：&quot;&gt;&lt;a href=&quot;#以application-x-www-url-encoded-方式发送数据-d-–data-：&quot; class=&quot;headerlink&quot; title=&quot;以application/x-www-url-encoded 方式发送数据(-d/–data)：&quot;&gt;&lt;/a&gt;以application/x-www-url-encoded 方式发送数据(-d/–data)：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;curl -d &amp;quot;username=sunnyxd&amp;amp;password=12345&amp;quot; URL
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;    
&lt;h4 id=&quot;以multipart-form-data-的方式发送数据-上传文件，-F-–form-：&quot;&gt;&lt;a href=&quot;#以multipart-form-data-的方式发送数据-上传文件，-F-–form-：&quot; class=&quot;headerlink&quot; title=&quot;以multipart/form-data 的方式发送数据(上传文件，-F/–form)：&quot;&gt;&lt;/a&gt;以multipart/form-data 的方式发送数据(上传文件，-F/–form)：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;curl -F filename=@/home/sunnyxd/file.tar.gz -F username=sunnyxd URL
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;设置cookie&quot;&gt;&lt;a href=&quot;#设置cookie&quot; class=&quot;headerlink&quot; title=&quot;设置cookie&quot;&gt;&lt;/a&gt;设置cookie&lt;/h3&gt;&lt;h4 id=&quot;使用cookie-b-–cookie&quot;&gt;&lt;a href=&quot;#使用cookie-b-–cookie&quot; class=&quot;headerlink&quot; title=&quot;使用cookie (-b/–cookie)&quot;&gt;&lt;/a&gt;使用cookie (-b/–cookie)&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;curl URL -b &amp;quot;username=sunnyxd;password=12345&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;保存cookie-c-–cookie-jar&quot;&gt;&lt;a href=&quot;#保存cookie-c-–cookie-jar&quot; class=&quot;headerlink&quot; title=&quot;保存cookie (-c/–cookie-jar)&quot;&gt;&lt;/a&gt;保存cookie (-c/–cookie-jar)&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;curl -d &amp;quot;username=sunnyxd&amp;amp;password=12345&amp;quot; -c ./cookie.txt URL 操作结束后把cookie写入文件cookie.txt
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;抓取页面-下载&quot;&gt;&lt;a href=&quot;#抓取页面-下载&quot; class=&quot;headerlink&quot; title=&quot;抓取页面(下载)&quot;&gt;&lt;/a&gt;抓取页面(下载)&lt;/h3&gt;&lt;p&gt;抓取页面保存到test.html：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -o test.html URL
或者curl URL &amp;gt; test.html

-O 下载特定文件，url需要指定到一个具体的文件
-C - 断点续传，- 自动推断出正确的续传位置，或者直接指定相应的字节偏移
-f 显示抓取错误信息
-x ip:port 使用代理
-s 不显示进度信息
-e/--referer 伪造来源地址
--limit-rate 50k 限制下载速度
--max-filesize bytes 指定可下载的最大文件大小
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;格式化显示响应信息&quot;&gt;&lt;a href=&quot;#格式化显示响应信息&quot; class=&quot;headerlink&quot; title=&quot;格式化显示响应信息&quot;&gt;&lt;/a&gt;格式化显示响应信息&lt;/h3&gt;&lt;p&gt;-w 一次完整且成功的操作后输出指定格式的内容到标准输出。&lt;/p&gt;
&lt;h4 id=&quot;查看接口响应时间&quot;&gt;&lt;a href=&quot;#查看接口响应时间&quot; class=&quot;headerlink&quot; title=&quot;查看接口响应时间&quot;&gt;&lt;/a&gt;查看接口响应时间&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;curl -o /dev/null -s -w &amp;quot;%{time_connect}:%{time_starttransfer}:%{time_total}\n&amp;quot; URL
第一个字段，是从命令启动到链接上用的时间
第二个字段，是开始传输数据所用的时间
第三个字段，是完成传输所用的时间
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;查看页面是否可用&quot;&gt;&lt;a href=&quot;#查看页面是否可用&quot; class=&quot;headerlink&quot; title=&quot;查看页面是否可用&quot;&gt;&lt;/a&gt;查看页面是否可用&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;curl -o /dev/null -s -w %{http_code} URL
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;监控接口可用性的一个简单demo：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;check result:&amp;quot;
cat monitor_url | while read line
do
status_code=`curl -o /dev/null -s -w %{http_code} $line`
if [ $status_code -eq 200 ]
then
echo ${line}&amp;quot;is ok&amp;quot;
else
echo ${line}&amp;quot;is fail&amp;quot;
fi
done
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;curl -w详细介绍：&lt;a href=&quot;http://www.letuknowit.com/post/17.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.letuknowit.com/post/17.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置浏览器代理-A-–user-agent&quot;&gt;&lt;a href=&quot;#设置浏览器代理-A-–user-agent&quot; class=&quot;headerlink&quot; title=&quot;设置浏览器代理 (-A/–user-agent)&quot;&gt;&lt;/a&gt;设置浏览器代理 (-A/–user-agent)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;curl URL -A &amp;quot;Mozilla/5.0
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;只打印响应头部信息&quot;&gt;&lt;a href=&quot;#只打印响应头部信息&quot; class=&quot;headerlink&quot; title=&quot;只打印响应头部信息&quot;&gt;&lt;/a&gt;只打印响应头部信息&lt;/h3&gt;&lt;p&gt;通过-I或者–head可以只打印出HTTP头部信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -I URL
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;用户认证-u-–user&quot;&gt;&lt;a href=&quot;#用户认证-u-–user&quot; class=&quot;headerlink&quot; title=&quot;用户认证(-u/–user)&quot;&gt;&lt;/a&gt;用户认证(-u/–user)&lt;/h3&gt;&lt;p&gt;用于HTTP或者FTP的认证，可以指定密码，也可以不指定密码在后续操作中输入密码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -u user:pwd URL
curl -u user URL
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;通用头部信息传递-H-–header&quot;&gt;&lt;a href=&quot;#通用头部信息传递-H-–header&quot; class=&quot;headerlink&quot; title=&quot;通用头部信息传递(-H/–header)&quot;&gt;&lt;/a&gt;通用头部信息传递(-H/–header)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;curl -H &amp;quot;Host:127.0.0.1&amp;quot; -H &amp;quot;accept-language:zh-cn&amp;quot; URL
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;自动跳转到新网址&quot;&gt;&lt;a href=&quot;#自动跳转到新网址&quot; class=&quot;headerlink&quot; title=&quot;自动跳转到新网址&quot;&gt;&lt;/a&gt;自动跳转到新网址&lt;/h3&gt;&lt;p&gt;有的网址是自动跳转的。使用-L参数，curl就会跳转到新的网址。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -L URL
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;设置请求超时时间&quot;&gt;&lt;a href=&quot;#设置请求超时时间&quot; class=&quot;headerlink&quot; title=&quot;设置请求超时时间&quot;&gt;&lt;/a&gt;设置请求超时时间&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;curl --connect-timeout seconds URL
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;设置最大传输时间-m-–max-time&quot;&gt;&lt;a href=&quot;#设置最大传输时间-m-–max-time&quot; class=&quot;headerlink&quot; title=&quot;设置最大传输时间(-m/–max-time)&quot;&gt;&lt;/a&gt;设置最大传输时间(-m/–max-time)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;curl -m seconds URL
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数详细介绍请看这里：&lt;a href=&quot;http://man.linuxde.net/curl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://man.linuxde.net/curl&lt;/a&gt;&lt;br&gt;参考文章：&lt;a href=&quot;http://blog.csdn.net/xifeijian/article/details/9367339&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/xifeijian/article/details/9367339&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;curl是做什么的&quot;&gt;&lt;a href=&quot;#curl是做什么的&quot; class=&quot;headerlink&quot; title=&quot;curl是做什么的&quot;&gt;&lt;/a&gt;curl是做什么的&lt;/h2&gt;&lt;p&gt;curl是利用URL语法在命令行方式下工作的开源文件传输工具，它支持http,https,ftp,ftps,telnet等多种协议。&lt;br&gt;常用于模拟提交web数据，与网站API交互(POST/GET请求，可以自定义发送header)，也可以用于下载(PS:专职下载还是用wget，支持recursive)。&lt;/p&gt;
&lt;h2 id=&quot;常用操作&quot;&gt;&lt;a href=&quot;#常用操作&quot; class=&quot;headerlink&quot; title=&quot;常用操作&quot;&gt;&lt;/a&gt;常用操作&lt;/h2&gt;&lt;h3 id=&quot;GET请求-G-–get-省略&quot;&gt;&lt;a href=&quot;#GET请求-G-–get-省略&quot; class=&quot;headerlink&quot; title=&quot;GET请求(-G/–get/省略)&quot;&gt;&lt;/a&gt;GET请求(-G/–get/省略)&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;curl http://www.xxxx.com/show?userId=111
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;POST请求&quot;&gt;&lt;a href=&quot;#POST请求&quot; class=&quot;headerlink&quot; title=&quot;POST请求&quot;&gt;&lt;/a&gt;POST请求&lt;/h3&gt;&lt;h4 id=&quot;以application-x-www-url-encoded-方式发送数据-d-–data-：&quot;&gt;&lt;a href=&quot;#以application-x-www-url-encoded-方式发送数据-d-–data-：&quot; class=&quot;headerlink&quot; title=&quot;以application/x-www-url-encoded 方式发送数据(-d/–data)：&quot;&gt;&lt;/a&gt;以application/x-www-url-encoded 方式发送数据(-d/–data)：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;curl -d &amp;quot;username=sunnyxd&amp;amp;password=12345&amp;quot; URL
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Linux命令" scheme="http://www.sunnyxd.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Linux" scheme="http://www.sunnyxd.com/tags/Linux/"/>
    
      <category term="curl" scheme="http://www.sunnyxd.com/tags/curl/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript中的作用域和作用域链</title>
    <link href="http://www.sunnyxd.com/2016/04/22/%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <id>http://www.sunnyxd.com/2016/04/22/理解JavaScript中的作用域和作用域链/</id>
    <published>2016-04-22T09:15:55.000Z</published>
    <updated>2016-04-22T09:45:32.406Z</updated>
    
    <content type="html">&lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;p&gt;&lt;code&gt;作用域就是变量与函数的可访问范围&lt;/code&gt;，即作用域控制着变量与函数的可见性和生命周期。&lt;br&gt;在JavaScript中，变量的作用域有全局作用域和局部作用域两种。&lt;/p&gt;
&lt;h2 id=&quot;作用域链&quot;&gt;&lt;a href=&quot;#作用域链&quot; class=&quot;headerlink&quot; title=&quot;作用域链&quot;&gt;&lt;/a&gt;作用域链&lt;/h2&gt;&lt;p&gt;函数对象有一个内部属性[[Scope]]，包含了函数被创建后的作用域中对象的集合，&lt;br&gt;这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。&lt;br&gt;示例：&lt;br&gt;当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;    function add(num1, num2){&lt;br&gt;      var sum = num1 + num2;&lt;br&gt;      return sum;&lt;br&gt;    }&lt;br&gt;在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量，如下图所示（注意：图片只列举了全部变量中的一部分）：&lt;br&gt;&lt;img src=&quot;http://7xnxzw.com1.z0.glb.clouddn.com/js作用域链_01.jpg&quot; alt=&quot;js作用域链_01&quot;&gt;&lt;br&gt;执行add函数时会创建一个称为&lt;code&gt;“运行期上下文(execution context)”&lt;/code&gt;的内部对象，运行期上下文定义了函数执行时的环境。&lt;br&gt;每个运行期上下文都有自己的作用域链，用于标识符解析。&lt;br&gt;当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象，这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。&lt;br&gt;它们共同组成了一个新的对象，叫&lt;code&gt;“活动对象(activation object)”&lt;/code&gt;，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示：&lt;br&gt;&lt;img src=&quot;http://7xnxzw.com1.z0.glb.clouddn.com/js作用域链_02.jpg&quot; alt=&quot;js作用域链_02&quot;&gt;&lt;br&gt;&lt;code&gt;在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。&lt;/code&gt;该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。&lt;/p&gt;
&lt;h2 id=&quot;作用域链和代码优化&quot;&gt;&lt;a href=&quot;#作用域链和代码优化&quot; class=&quot;headerlink&quot; title=&quot;作用域链和代码优化&quot;&gt;&lt;/a&gt;作用域链和代码优化&lt;/h2&gt;&lt;p&gt;从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。&lt;br&gt;如上图所示，因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：&lt;code&gt;如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;改变作用域链&quot;&gt;&lt;a href=&quot;#改变作用域链&quot; class=&quot;headerlink&quot; title=&quot;改变作用域链&quot;&gt;&lt;/a&gt;改变作用域链&lt;/h2&gt;&lt;p&gt;&lt;code&gt;函数每次执行时对应的运行期上下文都是独一无二的&lt;/code&gt;，所以多次调用同一个函数就会导致创建多个运行期上下文，当函数执行完毕，执行上下文会被销毁。每一个运行期上下文都和一个作用域链关联。一般情况下，在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响。&lt;br&gt;with语句是对象的快捷应用方式，用来避免书写重复代码。&lt;br&gt;对with语句来说，会将指定的对象添加到作用域链中，对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。&lt;br&gt;此时，作用域链中函数的所有局部变量所在的作用域对象会被推后，访问代价变高了。&lt;br&gt;在实际应用中，应少用with，把catch中的错误委托给一个函数处理。&lt;/p&gt;
&lt;h2 id=&quot;没有块级作用域&quot;&gt;&lt;a href=&quot;#没有块级作用域&quot; class=&quot;headerlink&quot; title=&quot;没有块级作用域&quot;&gt;&lt;/a&gt;没有块级作用域&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;if(true){
  var i = 0;
  i++;
}
console.log(i); //1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果在c、c++或java语言中，if语句执行完毕后i会被销毁，而在js中，if语句中的变量声明是添加到了当前函数的执行环境中，所以在if语句之后仍然可以正常访问。&lt;/p&gt;
&lt;h3 id=&quot;模仿块级作用域&quot;&gt;&lt;a href=&quot;#模仿块级作用域&quot; class=&quot;headerlink&quot; title=&quot;模仿块级作用域&quot;&gt;&lt;/a&gt;模仿块级作用域&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;(function(){
  //这里是块级作用域
})();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式，而紧随其后的另一对圆括号会立即调用这个函数。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;作用域就是变量和函数的可访问范围，通常，局部环境中的变量和函数是不能被外部环境访问的；&lt;/li&gt;
&lt;li&gt;作用域链决定了哪些数据能够被当前函数访问以及访问的顺序；&lt;/li&gt;
&lt;li&gt;函数创建时，会创建一个Global Object，填入它的作用域链；函数执行时，会创建一个运行期上下文的对象，它定义了函数执行时的环境。函数执行环境包含一个活动对象，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，它会被推入作用域链的最前端；&lt;/li&gt;
&lt;li&gt;函数执行过程，每遇到一个变量，都会经历一次标识符解析的过程(逐级向上搜索作用域链)以决定从哪里获取和存储数据；&lt;/li&gt;
&lt;li&gt;全局变量存在于运行期上下文作用域链的最末端，查找最慢，所以我们应该尽可能少使用全局变量，如果使用，就先用局部变量缓存下来；&lt;/li&gt;
&lt;li&gt;在运行期上下文运行的过程中，其作用域链只会被 with 语句和 catch 语句影响，应少用with，把catch中的错误委托给一个函数处理；&lt;/li&gt;
&lt;li&gt;js中没有块级作用域，但是我们可以模仿实现它。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h2&gt;&lt;p&gt;&lt;code&gt;作用域就是变量与函数的可访问范围&lt;/code&gt;，即作用域控制着变量与函数的可见性和生命周期。&lt;br&gt;在JavaScript中，变量的作用域有全局作用域和局部作用域两种。&lt;/p&gt;
&lt;h2 id=&quot;作用域链&quot;&gt;&lt;a href=&quot;#作用域链&quot; class=&quot;headerlink&quot; title=&quot;作用域链&quot;&gt;&lt;/a&gt;作用域链&lt;/h2&gt;&lt;p&gt;函数对象有一个内部属性[[Scope]]，包含了函数被创建后的作用域中对象的集合，&lt;br&gt;这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。&lt;br&gt;示例：&lt;br&gt;当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。
    
    </summary>
    
      <category term="web前端" scheme="http://www.sunnyxd.com/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://www.sunnyxd.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.sunnyxd.com/2016/04/18/hello-world/"/>
    <id>http://www.sunnyxd.com/2016/04/18/hello-world/</id>
    <published>2016-04-18T09:54:19.239Z</published>
    <updated>2016-04-22T09:46:15.095Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;
    
    </summary>
    
      <category term="hexo入门" scheme="http://www.sunnyxd.com/categories/hexo%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="博客搭建" scheme="http://www.sunnyxd.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
